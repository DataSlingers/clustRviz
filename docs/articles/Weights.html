<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Weight Selection for Convex Clustering and BiClustering • clustRviz</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Weight Selection for Convex Clustering and BiClustering">
<meta property="og:description" content="clustRviz">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">clustRviz</a>
        <span class="version label label-info" data-toggle="tooltip" data-placement="bottom" title="clustRviz is not yet on CRAN">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/clustRviz.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Tutorial.html">10-Minute Introduction to ClustRviz</a>
    </li>
    <li>
      <a href="../articles/Weights.html">Weight Selection for Convex Clustering and BiClustering</a>
    </li>
    <li>
      <a href="../articles/Algorithms.html">Computational Details of the CARP and CBASS Algorithms</a>
    </li>
    <li>
      <a href="../articles/Acknowledgements.html">Acknowledgements</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/DataSlingers/clustRviz/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="Weights_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Weight Selection for Convex Clustering and BiClustering</h1>
                        <h4 class="author">John Nagorski</h4>
            <address class="author_afil">
      Department of Statistics, Rice University<br><h4 class="author">Michael Weylandt</h4>
            <address class="author_afil">
      Department of Statistics, Rice University<br><a class="author_email" href="mailto:#"></a><a href="mailto:michael.weylandt@rice.edu" class="email">michael.weylandt@rice.edu</a>
      </address>
                              <h4 class="author">Genevera I. Allen</h4>
            <address class="author_afil">
      <div class="line-block">Departments of Statistics, Computer Science, and Electical and Computer Engineering, Rice University<br>
      Jan and Dan Duncan Neurological Research Institute, Baylor College of Medicine</div>
<br><a class="author_email" href="mailto:#"></a><a href="mailto:gallen@rice.edu" class="email">gallen@rice.edu</a>
      </address>
                  
            <h4 class="date">Last Updated: September 9, 2018</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/DataSlingers/clustRviz/blob/master/vignettes/Weights.Rmd"><code>vignettes/Weights.Rmd</code></a></small>
      <div class="hidden name"><code>Weights.Rmd</code></div>

    </address>
</div>

    
    

<p>In this note, we describe the role of weights in convex clustering and biclustering, the default weight scheme used in <code>CARP</code> and <code>CBASS</code>, and how to add implement custom weighting schemes in <code>clustRviz.</code></p>
<div id="the-role-of-weights-in-convex-clustering" class="section level2">
<h2 class="hasAnchor">
<a href="#the-role-of-weights-in-convex-clustering" class="anchor"></a>The Role of Weights in Convex Clustering</h2>
<p>Recall the convex clustering problem, as discussed in Hocking <em>et al.</em> <span class="citation">(2011)</span>, Chi and Lange <span class="citation">(2015)</span>, and Tan and Witten <span class="citation">(2015)</span>, among others:</p>
<p><span class="math display">\[
\underset{\boldsymbol{U}}{\textrm{minimize}} \;\; \frac{1}{2} \| \boldsymbol{X} - \boldsymbol{U} \|_F^2 + \lambda \sum_{l &lt; m}  w_{l,m} \| \boldsymbol{u}_l - \boldsymbol{u}_m \|_q
\]</span></p>
<p>We typically take <span class="math inline">\(q = 2\)</span>, though both <code>CARP</code> and <code>CBASS</code> support <span class="math inline">\(q = 1\)</span> as well.</p>
<p>It is well-known that, as <span class="math inline">\(\lambda\)</span> increases, the solution to this problem traces out a continuous set of clustering solutions,<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> ranging from each observation being its own cluster at <span class="math inline">\(\lambda = 0\)</span> to all observations being fused into a single cluster as <span class="math inline">\(\lambda\)</span> becomes large. Less well-studied in the literature is the effect of the weight terms <span class="math inline">\(\{w_{l, m}\}_{1 \leq l &lt; m \leq n}\)</span>. Hocking <em>et al.</em> <span class="citation">(2011)</span> noted that a Gaussian kernel weighting scheme of the form</p>
<p><span class="math display">\[w_{l, m} \propto \exp\left(-\phi \|\boldsymbol{x}_l - \boldsymbol{x}_m\|_2^2\right)\]</span></p>
<p>performed well in experiments, giving a clustering solution that respected the density of the data. Chi and Lange <span class="citation">(2015)</span> confirm the usefulness of this weighting scheme, and note that, for realistic data sets, many of these weights are quite small. To improve computational efficiency, they recommend dropping many of the smallest weights, reducing the penalty (fusion) term from a sum of <span class="math inline">\(\choose{n}{2}\)</span> terms to a much more tractable size. Since the dropped weights are typically several orders of magnitude smaller than the retained weights, omitting these terms has minimal impact on the resulting solution.</p>
<p>Our experience developing <code>CARP</code> and <code>CBASS</code> is similar: the Gaussian kernel weights work well in practice, and omitting smaller weights leads to significant increases in computational efficiency. For fully interactive data analysis, we find that using a relatively sparse set of weights is important, even with the speed advantages given by <code>CARP</code> and <code>CBASS</code>.</p>
<p>We note two properties that any sensible weighting scheme must satisfy and which are enforced internally by our software:</p>
<ul>
<li>all the weights must be non-negative; and</li>
<li>the adjacency graph implied by the weights must be fully connected.</li>
</ul>
<p>If the latter condition is not satisfied, the data are never fused into a single cluster, even as <span class="math inline">\(\lambda \to 0\)</span>, so our algorithms never terminate. Relatedly, if the second condition is not satisfied, the clustering problem is fully separable across groups of observations and data from different parts of the graph are “in the dark” about each other: the same solution could be obtained by clustering the two sets of observations separately, which is rarely what we want in a clustering algorithm.</p>
<div id="additional-requirements-for-convex-biclustering" class="section level3">
<h3 class="hasAnchor">
<a href="#additional-requirements-for-convex-biclustering" class="anchor"></a>Additional Requirements for Convex BiClustering</h3>
<p>Chi, Allen, and Baraniuk <span class="citation">(2017)</span> propose a convex formulation of biclustering:</p>
<p><span class="math display">\[
\underset{\boldsymbol{U}}{\textrm{minimize}} \;\; \frac{1}{2} \| \boldsymbol{X} - \boldsymbol{U} \|_F^2 + \lambda \left(\sum_{l &lt; m}  w_{l,m} \| \boldsymbol{U}_{l\cdot} - \boldsymbol{U}_{m\cdot} \|_q + \sum_{j &lt; k} w_{j, k} \|\boldsymbol{U}_{\cdot j} + \boldsymbol{U}_{\cdot k}\|_q\right)
\]</span></p>
<p>Here we doubly fuse our data: combining row-wise fusion (the first part of the penalty term) to cluster observations with column-wise fusion (the second part of the penalty term) to cluster features. The resulting problem induces <em>biclustering;</em> see Chi <em>et al.</em> <span class="citation">(2017)</span> for more details.</p>
<p>As Chi <em>et al.</em> note, an additional requirement on the weights is necessary to obtain sensible solutions:<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<ul>
<li>the row-wise observation weights must sum to <span class="math inline">\(n^{-1/2}\)</span> while the column-wise feature weights must sum to <span class="math inline">\(p^{-1/2}\)</span>.</li>
</ul>
<p>This behavior is automatically enforced by <code>CBASS</code>. That is, after the weights are calculated, they are (silently) renormalized to have an appropriate sum.</p>
</div>
</div>
<div id="sparse-gaussian-rbf-weights-clustrvizs-default-weighting-scheme" class="section level2">
<h2 class="hasAnchor">
<a href="#sparse-gaussian-rbf-weights-clustrvizs-default-weighting-scheme" class="anchor"></a>Sparse Gaussian RBF Weights: <code>clustRviz</code>’s Default Weighting Scheme</h2>
<p>As noted above, “sparsified” Gaussian RBF weights provide a robust and useful trade-off between statistical and computational performance. As such, they are the default weighting scheme used for both <code>CARP</code> and <code>CBASS.</code></p>
<div id="selecting-the-scale-parameter-phi" class="section level3">
<h3 class="hasAnchor">
<a href="#selecting-the-scale-parameter-phi" class="anchor"></a>Selecting the Scale Parameter <span class="math inline">\(\phi\)</span>
</h3>
<p>When interactively visualizing clustering results, we generally want our clusters to be joined together smoothly. To achieve this goal, we select the weight parameter <span class="math inline">\(\phi\)</span> to maximize the variance of the clustering weights. While this does not guarantee the smoothest possible clustering, we have found it to be a useful heuristic. That is, if not specified by the user, we select:</p>
<p><span class="math display">\[\hat{\phi} = \underset{\phi}{\textrm{arg max}}\;\; \text{Var}\left(\exp\left\{-\phi \|\boldsymbol{x}_i - \boldsymbol{x}_j\|_2^2\right\}\right)\]</span></p>
<p>where the variance is taken over all pairs <span class="math inline">\(i, j\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<p>This is implemented in <code>clustRviz</code> via the <code>dense_rbf_kernel_weights</code> function. Note that this is a <em>function factory</em> - it returns a function which can be called to actually calculate the weights:</p>
<div class="sourceCode" id="cb1"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="no">clustRviz</span>)</pre></body></html></div>
<pre><code>## Registered S3 method overwritten by 'seriation':
##   method         from 
##   reorder.hclust gclus</code></pre>
<div class="sourceCode" id="cb3"><html><body><pre class="r"><span class="no">get_upper_triangle</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">x</span>) <span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span>(<span class="no">x</span>[<span class="fu"><a href="https://rdrr.io/r/base/lower.tri.html">upper.tri</a></span>(<span class="no">x</span>)])

<span class="no">weight_func</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/rbf_kernel_weights.html">dense_rbf_kernel_weights</a></span>()
<span class="no">weights</span> <span class="kw">&lt;-</span> <span class="fu">weight_func</span>(<span class="no">presidential_speech</span>)$<span class="no">weight_mat</span>

<span class="no">weights</span>[<span class="fl">1</span>:<span class="fl">5</span>, <span class="fl">1</span>:<span class="fl">5</span>]</pre></body></html></div>
<pre><code>##                   Abraham Lincoln Andrew Jackson Andrew Johnson Barack Obama
## Abraham Lincoln       0.000000000   0.3701283153    0.719439416 0.0024191769
## Andrew Jackson        0.370128315   0.0000000000    0.424126484 0.0006325056
## Andrew Johnson        0.719439416   0.4241264843    0.000000000 0.0022576824
## Barack Obama          0.002419177   0.0006325056    0.002257682 0.0000000000
## Benjamin Harrison     0.271504288   0.3437737065    0.345265065 0.0015796098
##                   Benjamin Harrison
## Abraham Lincoln          0.27150429
## Andrew Jackson           0.34377371
## Andrew Johnson           0.34526507
## Barack Obama             0.00157961
## Benjamin Harrison        0.00000000</code></pre>
<p>We see here that <span class="math inline">\(\phi\)</span> was automatically selected, yielding a variance of</p>
<div class="sourceCode" id="cb5"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">var</a></span>(<span class="fu">get_upper_triangle</span>(<span class="no">weights</span>))</pre></body></html></div>
<pre><code>## [1] 0.03501288</code></pre>
<p>and a nice “spread” of weights:</p>
<div class="sourceCode" id="cb7"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span>(<span class="fu">get_upper_triangle</span>(<span class="no">weights</span>),
     <span class="kw">col</span>    <span class="kw">=</span> <span class="st">"grey80"</span>,
     <span class="kw">border</span> <span class="kw">=</span> <span class="st">"white"</span>,
     <span class="kw">breaks</span> <span class="kw">=</span> <span class="fl">30</span>,
     <span class="kw">xlab</span>   <span class="kw">=</span> <span class="st">"Dense RBF Kernel Weight Value"</span>,
     <span class="kw">main</span>   <span class="kw">=</span> <span class="st">"Highly Variable RBF Weights"</span>)</pre></body></html></div>
<p><img src="Weights_files/figure-html/unnamed-chunk-3-1.png" width="700"></p>
<p>If we had prior information about a good choice of the scale parameter <span class="math inline">\(\phi\)</span>, we could supply it to the <em>initial</em> call to <code>dense_rbf_kernel_weights</code>:</p>
<div class="sourceCode" id="cb8"><html><body><pre class="r"><span class="no">weight_func_phi_1</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/rbf_kernel_weights.html">dense_rbf_kernel_weights</a></span>(<span class="kw">phi</span> <span class="kw">=</span> <span class="fl">1</span>)
<span class="no">weights_phi_1</span> <span class="kw">&lt;-</span> <span class="fu">weight_func_phi_1</span>(<span class="no">presidential_speech</span>)$<span class="no">weight_mat</span>

<span class="no">weights_phi_1</span>[<span class="fl">1</span>:<span class="fl">5</span>, <span class="fl">1</span>:<span class="fl">5</span>]</pre></body></html></div>
<pre><code>##                   Abraham Lincoln Andrew Jackson Andrew Johnson  Barack Obama
## Abraham Lincoln      0.000000e+00   6.842756e-44   5.005216e-15 2.326824e-262
## Andrew Jackson       6.842756e-44   0.000000e+00   5.617450e-38 1.277654e-320
## Andrew Johnson       5.005216e-15   5.617450e-38   0.000000e+00 2.324261e-265
## Barack Obama        2.326824e-262  1.277654e-320  2.324261e-265  0.000000e+00
## Benjamin Harrison    2.385993e-57   4.239022e-47   6.535273e-47 7.161116e-281
##                   Benjamin Harrison
## Abraham Lincoln        2.385993e-57
## Andrew Jackson         4.239022e-47
## Andrew Johnson         6.535273e-47
## Barack Obama          7.161116e-281
## Benjamin Harrison      0.000000e+00</code></pre>
<p>Not surprisingly, this gives weights with much lower variance than before.</p>
<div class="sourceCode" id="cb10"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">var</a></span>(<span class="fu">get_upper_triangle</span>(<span class="no">weights_phi_1</span>))</pre></body></html></div>
<pre><code>## [1] 1.926745e-30</code></pre>
<p>So far, we have used (squared) Euclidean distance to define our kernel, but we can in fact use any distance function <span class="math inline">\(d\)</span> to calculate weights as: <span class="math display">\[\phi \propto \exp\left\{-\phi d(\boldsymbol{x}_i, \boldsymbol{x}_j)^2\right\}\]</span></p>
<p>To use alternate weight functions, <span class="math inline">\(d(\cdot, \cdot)\)</span>, pass the <code>dist.method</code> and <code>p</code> arguments to <code>dense_rbf_kernel_weights.</code> For example, if we wanted to use the <span class="math inline">\(\ell_4\)</span> metric, we could use</p>
<div class="sourceCode" id="cb12"><html><body><pre class="r"><span class="fu"><a href="../reference/rbf_kernel_weights.html">dense_rbf_kernel_weights</a></span>(<span class="kw">dist.method</span> <span class="kw">=</span> <span class="st">"minkowski"</span>, <span class="kw">p</span> <span class="kw">=</span> <span class="fl">4</span>)</pre></body></html></div>
<p>See the <code>dist</code> function in the <code>stats</code> package for supported distances.</p>
</div>
<div id="selecting-the-sparsification-parameter-k" class="section level3">
<h3 class="hasAnchor">
<a href="#selecting-the-sparsification-parameter-k" class="anchor"></a>Selecting the Sparsification Parameter <span class="math inline">\(k\)</span>
</h3>
<p>Once we have a dense set of weights, we typically wish to <em>sparsify</em> them to improve computational speed. There are several ways to do so, but perhaps the simplest is to take the <span class="math inline">\(k\)</span>-nearest neighbors graph for some <span class="math inline">\(k\)</span>. That is, we zero out most entries in the weight matrix, keeping <span class="math inline">\(w_{ij}\)</span> only if <span class="math inline">\(i\)</span> is a <span class="math inline">\(k\)</span>-nearest neighbor of <span class="math inline">\(j\)</span> or vice versa.</p>
<p>Sparse weights can be calculated via the <code>sparse_rbf_kernel_weights</code> function factory, which works like the <code>dense_rbf_kernel_weights</code> function but includes an extra optional parameter <span class="math inline">\(k\)</span>. By default <span class="math inline">\(k\)</span> is chosen as small as possible, subject to the graph still being connected:</p>
<div class="sourceCode" id="cb13"><html><body><pre class="r"><span class="no">weight_func</span>    <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/rbf_kernel_weights.html">sparse_rbf_kernel_weights</a></span>()
<span class="no">weight_mat</span>     <span class="kw">&lt;-</span> <span class="fu">weight_func</span>(<span class="no">presidential_speech</span>)$<span class="no">weight_mat</span>
<span class="no">weight_details</span> <span class="kw">&lt;-</span> <span class="fu">weight_func</span>(<span class="no">presidential_speech</span>)$<span class="no">type</span>

<span class="no">weight_mat</span>[<span class="fl">1</span>:<span class="fl">5</span>, <span class="fl">1</span>:<span class="fl">5</span>]</pre></body></html></div>
<pre><code>##                   Abraham Lincoln Andrew Jackson Andrew Johnson Barack Obama
## Abraham Lincoln         0.0000000              0      0.7194394            0
## Andrew Jackson          0.0000000              0      0.0000000            0
## Andrew Johnson          0.7194394              0      0.0000000            0
## Barack Obama            0.0000000              0      0.0000000            0
## Benjamin Harrison       0.0000000              0      0.0000000            0
##                   Benjamin Harrison
## Abraham Lincoln                   0
## Andrew Jackson                    0
## Andrew Johnson                    0
## Barack Obama                      0
## Benjamin Harrison                 0</code></pre>
<p>We immediately see that these weights are significantly more sparse than before. In fact, we see that for this example, approximately 88% of the weights have been zeroed out:</p>
<div class="sourceCode" id="cb15"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="fl">100</span> * <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="fu">get_upper_triangle</span>(<span class="no">weight_mat</span>) <span class="kw">==</span> <span class="fl">0</span>))</pre></body></html></div>
<pre><code>## [1] 88</code></pre>
<div class="sourceCode" id="cb17"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span>(<span class="fu">get_upper_triangle</span>(<span class="no">weight_mat</span>),
     <span class="kw">col</span>    <span class="kw">=</span> <span class="st">"grey80"</span>,
     <span class="kw">border</span> <span class="kw">=</span> <span class="st">"white"</span>,
     <span class="kw">breaks</span> <span class="kw">=</span> <span class="fl">30</span>,
     <span class="kw">xlab</span>   <span class="kw">=</span> <span class="st">"Sparse RBF Kernel Weight Value"</span>,
     <span class="kw">main</span>   <span class="kw">=</span> <span class="st">"KNN Sparsified RBF Weights"</span>)</pre></body></html></div>
<p><img src="Weights_files/figure-html/unnamed-chunk-9-1.png" width="700"></p>
<p>We see here that <span class="math inline">\(k = 4\)</span> was the smallest <span class="math inline">\(k\)</span> that gave a fully connected graph:</p>
<div class="sourceCode" id="cb18"><html><body><pre class="r"><span class="no">weight_details</span>$<span class="no">k</span></pre></body></html></div>
<pre><code>## [1] 4</code></pre>
<p>If the user supplied a smaller <span class="math inline">\(k\)</span> (resulting in a non-connected graph), an error would be thrown:</p>
<div class="sourceCode" id="cb20"><html><body><pre class="r"><span class="fu"><a href="../reference/rbf_kernel_weights.html">sparse_rbf_kernel_weights</a></span>(<span class="kw">k</span> <span class="kw">=</span> <span class="fl">3</span>)(<span class="no">presidential_speech</span>)</pre></body></html></div>
<pre><code>## Error: k = 3 does not give a fully connected graph. Convex (bi)clustering will not converge. (Called from sparse_rbf_kernel_weights)</code></pre>
<p>The distance metric used can be changed by passing additional arguments to the function factory as before:</p>
<div class="sourceCode" id="cb22"><html><body><pre class="r"><span class="fu"><a href="../reference/rbf_kernel_weights.html">sparse_rbf_kernel_weights</a></span>(<span class="kw">dist.method</span> <span class="kw">=</span> <span class="st">"canberra"</span>)(<span class="no">presidential_speech</span>)</pre></body></html></div>
</div>
<div id="setting-carp-weights" class="section level3">
<h3 class="hasAnchor">
<a href="#setting-carp-weights" class="anchor"></a>Setting <code>CARP</code> Weights</h3>
<p>By default, <code>CARP</code> uses Sparse RBF kernel weights, with data-driven <span class="math inline">\(\phi, k\)</span> and the Euclidean distance. These can be changed by passing the result of <code>sparse_rbf_kernel_weights</code> to <code>CARP</code>. For example, if we wanted to use the Canberra distance with <code>k = 10</code> neighbors, we would call <code>CARP</code> as:</p>
<div class="sourceCode" id="cb23"><html><body><pre class="r"><span class="fu"><a href="../reference/CARP.html">CARP</a></span>(<span class="no">presidential_speech</span>, <span class="kw">weights</span> <span class="kw">=</span> <span class="fu"><a href="../reference/rbf_kernel_weights.html">sparse_rbf_kernel_weights</a></span>(<span class="kw">dist.method</span> <span class="kw">=</span> <span class="st">"canberra"</span>, <span class="kw">k</span> <span class="kw">=</span> <span class="fl">10</span>))</pre></body></html></div>
<pre><code>## CARP Fit Summary
## ====================
## 
## Algorithm: CARP (t = 1.05) 
## Fit Time: 0.270 secs 
## Total Time: 1.039 secs 
## 
## Number of Observations: 44 
## Number of Variables:    75 
## 
## Pre-processing options:
##  - Columnwise centering: TRUE 
##  - Columnwise scaling:   FALSE 
## 
## Weights:
##  - Source: Radial Basis Function Kernel Weights
##  - Distance Metric: Canberra
##  - Scale parameter (phi): 0.001 [Data-Driven]
##  - Sparsified: 10 Nearest Neighbors [User-Supplied]</code></pre>
<p>Note that the <code>weights</code> function is called on the <em>pre-processed</em> data matrix, not the raw data matrix.</p>
</div>
<div id="setting-cbass-weights" class="section level3">
<h3 class="hasAnchor">
<a href="#setting-cbass-weights" class="anchor"></a>Setting <code>CBASS</code> Weights</h3>
<p><code>CBASS</code> requires two sets of weights, one for rows and one for columns. The interface is the same as for <code>CARP</code>, but we now can supply the <code>row_weights</code> and <code>col_weights</code> arguments separately. The former will be used as the <code>weights</code> argument to <code>CARP</code>; the latter will be used called on the <em>transpose</em> of the pre-processed data, since it is used to calculate column weights. The weights are computed independently (with possibly different choices of <span class="math inline">\(\phi\)</span> and <span class="math inline">\(k\)</span>) and can be controlled separately: <em>e.g.</em></p>
<div class="sourceCode" id="cb25"><html><body><pre class="r"><span class="fu"><a href="../reference/CBASS.html">CBASS</a></span>(<span class="no">presidential_speech</span>,
      <span class="kw">col_weights</span> <span class="kw">=</span> <span class="fu"><a href="../reference/rbf_kernel_weights.html">sparse_rbf_kernel_weights</a></span>(<span class="kw">dist.method</span> <span class="kw">=</span> <span class="st">"canberra"</span>, <span class="kw">k</span> <span class="kw">=</span> <span class="fl">4</span>),
      <span class="kw">row_weights</span> <span class="kw">=</span> <span class="fu"><a href="../reference/rbf_kernel_weights.html">sparse_rbf_kernel_weights</a></span>(<span class="kw">dist.method</span> <span class="kw">=</span> <span class="st">"maximum"</span>, <span class="kw">phi</span> <span class="kw">=</span> <span class="fl">2</span>))</pre></body></html></div>
<pre><code>## CBASS Fit Summary
## ====================
## 
## Algorithm: CBASS (t = 1.01) 
## Fit Time: 6.031 secs 
## Total Time: 10.392 secs 
## 
## Number of Rows: 44 
## Number of Columns: 75 
## 
## Pre-processing options:
##  - Global centering: TRUE 
## 
## Row Weights:
##  - Source: Radial Basis Function Kernel Weights
##  - Distance Metric: Maximum
##  - Scale parameter (phi): 2 [User-Supplied]
##  - Sparsified: 2 Nearest Neighbors [Data-Driven]
## 
## Column Weights:
##  - Source: Radial Basis Function Kernel Weights
##  - Distance Metric: Canberra
##  - Scale parameter (phi): 0.001 [Data-Driven]
##  - Sparsified: 4 Nearest Neighbors [User-Supplied]</code></pre>
<p>As mentioned above, <code>CBASS</code> rescales the resulting weights to ensure proper biclustering.</p>
</div>
</div>
<div id="custom-weighting-schemes" class="section level2">
<h2 class="hasAnchor">
<a href="#custom-weighting-schemes" class="anchor"></a>Custom Weighting Schemes</h2>
<p>Even though the Sparse Gaussian RBF scheme is generally a good default choice, users may wish to use different weighting schemes with <code>clustRviz,</code> particularly if additional information or domain knowledge are available. To this end, both <code>CARP</code> and <code>CBASS</code> can use custom weighting schemes. We describe the different interfaces to this functionality in <code>CARP</code> below, and note that <code>CBASS</code> has the same behavior.</p>
<div id="custom-weight-matrix" class="section level3">
<h3 class="hasAnchor">
<a href="#custom-weight-matrix" class="anchor"></a>Custom Weight Matrix</h3>
<p>The easiest way to use custom weights with <code>clustRviz</code> is to supply a weight matrix as the <code>weights</code> matrix. <code>clustRviz</code> will perform some basic correctness checks, but will otherwise use your weights “as is.”</p>
<p>For example, if we wanted to use “chain” weights to cluster the presidents in alphabetical order, we could do so as follows:</p>
<div class="sourceCode" id="cb27"><html><body><pre class="r"><span class="no">weight_mat</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="fl">0</span>,
                     <span class="kw">nrow</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">presidential_speech</span>),
                     <span class="kw">ncol</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">presidential_speech</span>))
<span class="no">weight_mat</span>[<span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">presidential_speech</span>) - <span class="fl">1</span>),
                 <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">presidential_speech</span>)))] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="no">weight_mat</span>[<span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">presidential_speech</span>)),
                 <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">presidential_speech</span>) - <span class="fl">1</span>))] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/image.html">image</a></span>(<span class="no">weight_mat</span>)</pre></body></html></div>
<p><img src="Weights_files/figure-html/unnamed-chunk-15-1.png" width="700"></p>
<div class="sourceCode" id="cb28"><html><body><pre class="r"><span class="no">carp_fit_chain_weights</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/CARP.html">CARP</a></span>(<span class="no">presidential_speech</span>, <span class="kw">weights</span> <span class="kw">=</span> <span class="no">weight_mat</span>)
<span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span>(<span class="no">carp_fit_chain_weights</span>)</pre></body></html></div>
<pre><code>## CARP Fit Summary
## ====================
## 
## Algorithm: CARP (t = 1.05) 
## Fit Time: 0.063 secs 
## Total Time: 0.325 secs 
## 
## Number of Observations: 44 
## Number of Variables:    75 
## 
## Pre-processing options:
##  - Columnwise centering: TRUE 
##  - Columnwise scaling:   FALSE 
## 
## Weights:
##  - Source: User-Provided Matrix</code></pre>
<p>We note that the resulting clustering is essentially nonsense, but does respect our weights, for the most part:</p>
<div class="sourceCode" id="cb30"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/plot.html">plot</a></span>(<span class="no">carp_fit_chain_weights</span>)</pre></body></html></div>
<p><img src="Weights_files/figure-html/unnamed-chunk-17-1.png" width="700"></p>
</div>
<div id="custom-weight-function" class="section level3">
<h3 class="hasAnchor">
<a href="#custom-weight-function" class="anchor"></a>Custom Weight Function</h3>
<p>If a weight scheme is used repeatedly, it may be useful to wrap it in a function which will then be called on the pre-processed data. For example, our “chain weight” example from above could be written as:</p>
<div class="sourceCode" id="cb31"><html><body><pre class="r"><span class="no">chain_weights</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">X</span>){
  <span class="no">weight_mat</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="fl">0</span>, <span class="kw">nrow</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">X</span>), <span class="kw">ncol</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">X</span>))
  <span class="no">weight_mat</span>[<span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">X</span>) - <span class="fl">1</span>),
                   <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">X</span>)))] <span class="kw">&lt;-</span> <span class="fl">1</span>
  <span class="no">weight_mat</span>[<span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">X</span>)),
                   <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">NROW</a></span>(<span class="no">X</span>) - <span class="fl">1</span>))] <span class="kw">&lt;-</span> <span class="fl">1</span>

  <span class="no">weight_mat</span>
}
<span class="fu"><a href="../reference/CARP.html">CARP</a></span>(<span class="no">presidential_speech</span>, <span class="kw">weights</span> <span class="kw">=</span> <span class="no">chain_weights</span>)</pre></body></html></div>
<pre><code>## Pre-computing weights and edge sets</code></pre>
<pre><code>## Computing Convex Clustering [CARP] Path</code></pre>
<pre><code>## Post-processing</code></pre>
<pre><code>## CARP Fit Summary
## ====================
## 
## Algorithm: CARP (t = 1.05) 
## Fit Time: 0.061 secs 
## Total Time: 0.675 secs 
## 
## Number of Observations: 44 
## Number of Variables:    75 
## 
## Pre-processing options:
##  - Columnwise centering: TRUE 
##  - Columnwise scaling:   FALSE 
## 
## Weights:
##  - Source: User-Provided Function</code></pre>
<p>Writing the weight scheme as a function is particularly useful for biclustering, <em>e.g.</em>:</p>
<div class="sourceCode" id="cb36"><html><body><pre class="r"><span class="no">cbass_chain_fit</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/CBASS.html">CBASS</a></span>(<span class="no">presidential_speech</span>,
                         <span class="kw">row_weights</span> <span class="kw">=</span> <span class="no">chain_weights</span>,
                         <span class="kw">col_weights</span> <span class="kw">=</span> <span class="no">chain_weights</span>)</pre></body></html></div>
<pre><code>## Pre-computing column weights and edge sets</code></pre>
<pre><code>## Pre-computing row weights and edge sets</code></pre>
<pre><code>## Computing Convex Bi-Clustering [CBASS] Path</code></pre>
<pre><code>## Post-processing rows</code></pre>
<pre><code>## Post-processing columns</code></pre>
<div class="sourceCode" id="cb42"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/plot.html">plot</a></span>(<span class="no">cbass_chain_fit</span>, <span class="kw">type</span><span class="kw">=</span><span class="st">"col.dendrogram"</span>)</pre></body></html></div>
<p><img src="Weights_files/figure-html/unnamed-chunk-20-1.png" width="700"></p>
<p>Note that the print method for <code>CARP</code> and <code>CBASS</code> knows that the weights were computed based on a user-supplied function, but cannot give more information than that. It is possible to provide a more complex function which will lead to more informative output, though it is beyond the scope of this vignette.</p>
</div>
<div id="example-spacc-weights" class="section level3">
<h3 class="hasAnchor">
<a href="#example-spacc-weights" class="anchor"></a>Example: SpaCC Weights</h3>
<p>Nagorski and Allen <span class="citation">(2018)</span> propose the use of a spatial weighting scheme to cluster genomic regions. It is easy to implement a version of their scheme using <code>clustRviz</code> support for custom weight schemes:</p>
<div class="sourceCode" id="cb43"><html><body><pre class="r"><span class="no">spacc_carp</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">X</span>, <span class="no">coordinates</span>, <span class="no">...</span>,
                       <span class="no">dist.cutoff</span> <span class="kw">=</span> <span class="fl">20000</span>, <span class="co">## Distances from SpaCC_Methy in the SpaCCr package</span>
                       <span class="no">sigma</span> <span class="kw">=</span> <span class="fl">2e-4</span>){
  <span class="co">## This is not a robust / tested implementation</span>
  <span class="co">##</span>
  <span class="co">## It is provided for demonstration purposes only</span>
  <span class="no">spacc_weights</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">X</span>){
    <span class="no">distance_mat</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/dist.html">dist</a></span>(<span class="no">coordinates</span>))
    <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(- <span class="no">sigma</span> * <span class="no">distance_mat</span>) * (<span class="no">distance_mat</span> <span class="kw">&lt;</span> <span class="no">dist.cutoff</span>)
  }

  <span class="fu"><a href="../reference/CARP.html">CARP</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">X</span>), <span class="kw">weights</span> <span class="kw">=</span> <span class="no">spacc_weights</span>, <span class="no">...</span>)
}</pre></body></html></div>
<p>Note that this implementation will not work as is on the <code>SpaCC_Methy</code> example in the <code>SpaCCr</code> package because the adjacency graph implied by the SpaCC scheme on the example is not fully connected (the probes were at well-separated genomic locations). A more clever implementation would take advantage of this disconnectedness to separate the problem into disjoint subproblems.</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<div id="refs" class="references">
<div id="ref-Chi:2017">
<p>Chi, Eric C., Genevera I. Allen, and Richard G. Baraniuk. 2017. “Convex Biclustering.” <em>Biometrics</em> 73 (1): 10–19. <a href="https://doi.org/10.1111/biom.12540">https://doi.org/10.1111/biom.12540</a>.</p>
</div>
<div id="ref-Chi:2015">
<p>Chi, Eric C., and Kenneth Lange. 2015. “Splitting Methods for Convex Clustering.” <em>Journal of Computational and Graphical Statistics</em> 24 (4): 994–1013. <a href="https://doi.org/10.1080/10618600.2014.948181">https://doi.org/10.1080/10618600.2014.948181</a>.</p>
</div>
<div id="ref-Hocking:2011">
<p>Hocking, Toby Dylan, Armand Joulin, Francis Bach, and Jean-Philippe Vert. 2011. “Clusterpath: An Algorithm for Clustering Using Convex Fusion Penalties.” In <em>ICML 2011: Proceedings of the 28th International Conference on Machine Learning</em>, edited by Lise Getoor and Tobias Scheffer, 745–52. Bellevue, Washington, USA: ACM. <a href="http://www.icml-2011.org/papers/419_icmlpaper.pdf">http://www.icml-2011.org/papers/419_icmlpaper.pdf</a>.</p>
</div>
<div id="ref-Nagorski:2018">
<p>Nagorski, John, and Genevera I. Allen. 2018. “Genomic Region Detection via Spatial Convex Clustering.” <em>PLoS One</em> 13 (9): e0203007. <a href="https://doi.org/10.1371/journal.pone.0203007">https://doi.org/10.1371/journal.pone.0203007</a>.</p>
</div>
<div id="ref-Tan:2015">
<p>Tan, Kean Ming, and Daniela Witten. 2015. “Statistical Properties of Convex Clustering.” <em>Electronic Journal of Statistics</em> 9 (2): 2324–47. <a href="https://doi.org/10.1214/15-EJS1074">https://doi.org/10.1214/15-EJS1074</a>.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>The so-called “cluster-path” in the terminology of Hocking <em>et al.</em> <span class="citation">(2011)</span>.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Note that Chi <em>et al.</em> require the <em>column</em> weights to sum to <span class="math inline">\(n^{-1/2}\)</span> and the <em>row</em> weights to sum to <span class="math inline">\(p^{-1/2}\)</span>, because their data matrix <span class="math inline">\(X \in \mathbb{R}^{p \times n}\)</span> is the transpose of ours.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>The above maximization is not explicitly performed, but the maximum over a relatively corse gride is used.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Michael Weylandt, John Nagorski, Genevera Allen, Daniel Englund, Yue Zhuo.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
