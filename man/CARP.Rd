% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/carp.R
\name{CARP}
\alias{CARP}
\title{Compute \code{CARP} (Convex Clustering) Solution Path}
\usage{
CARP(
  X,
  ...,
  weights = sparse_rbf_kernel_weights(k = "auto", phi = "auto", dist.method =
    "euclidean", p = 2),
  labels = rownames(X),
  X.center = TRUE,
  X.scale = FALSE,
  back_track = FALSE,
  exact = FALSE,
  norm = 2,
  t = 1.05,
  npcs = min(4L, NCOL(X), NROW(X)),
  dendrogram.scale = NULL,
  impute_func = function(X) {     if (anyNA(X))          missForest(X)$ximp     else X
    },
  status = (interactive() && (clustRviz_logger_level() \%in\% c("MESSAGE", "WARNING",
    "ERROR")))
)
}
\arguments{
\item{X}{The data matrix (\eqn{X \in R^{n \times p}}{X}): rows correspond to
the observations (to be clustered) and columns to the variables (which
will not be clustered). If \code{X} has missing values - \code{NA} or
\code{NaN} values - they will be automatically imputed.}

\item{...}{Unused arguements. An error will be thrown if any unrecognized
arguments as given. All arguments other than \code{X} must be given
by name.}

\item{weights}{One of the following: \itemize{
\item A function which, when called with argument \code{X},
      returns an b-by-n matrix of fusion weights.
\item A matrix of size n-by-n containing fusion weights
}}

\item{labels}{A character vector of length \eqn{n}: observations (row) labels}

\item{X.center}{A logical: Should \code{X} be centered columnwise?}

\item{X.scale}{A logical: Should \code{X} be scaled columnwise?}

\item{back_track}{A logical: Should back-tracking be used to exactly identify fusions?
By default, back-tracking is not used.}

\item{exact}{A logical: Should the exact solution be computed using an iterative algorithm?
By default, algorithmic regularization is applied and the exact solution
is not computed. Setting \code{exact = TRUE} often significantly increases
computation time.}

\item{norm}{Which norm to use in the fusion penalty? Currently only \code{1}
and \code{2} (default) are supported.}

\item{t}{A number greater than 1: the size of the multiplicative update to
the cluster fusion regularization parameter (not used by
back-tracking variants). Typically on the scale of \code{1.005} to \code{1.1}.}

\item{npcs}{An integer >= 2. The number of principal components to compute
for path visualization.}

\item{dendrogram.scale}{A character string denoting how the scale of dendrogram
regularization proportions should be visualized.
Choices are \code{'original'} or \code{'log'}; if not
provided, a data-driven heuristic choice is used.}

\item{impute_func}{A function used to impute missing data in \code{X}. By default,
the \code{\link[missForest]{missForest}} function from the
package of the same name is used. This provides a flexible
potentially non-linear imputation function. This function
has to return a data matrix with no \code{NA} values.
Note that, consistent with base \code{R}, both \code{NaN}
and \code{NA} are treaded as "missing values" for imputation.}

\item{status}{Should a status message be printed to the console?}
}
\value{
An object of class \code{CARP} containing the following elements (among others):
        \itemize{
        \item \code{X}: the original data matrix
        \item \code{n}: the number of observations (rows of \code{X})
        \item \code{p}: the number of variables (columns of \code{X})
        \item \code{alg.type}: the \code{CARP} variant used
        \item \code{X.center}: a logical indicating whether \code{X} was centered
                               column-wise before clustering
        \item \code{X.scale}: a logical indicating whether \code{X} was scaled
                              column-wise before centering
        \item \code{weight_type}: a record of the scheme used to create
                                  fusion weights
        }
}
\description{
\code{CARP} returns a fast approximation to the Convex Clustering
solution path along with visualizations such as dendrograms and
cluster paths. \code{CARP} solves the Convex Clustering problem via an efficient
Algorithmic Regularization scheme.
}
\examples{
carp_fit <- CARP(presidential_speech[1:10,1:4])
print(carp_fit)
plot(carp_fit)
}
